{"version":3,"file":"index-vzWIEM6S.js","sources":["../../../../../../packages/pit-map/index.ts"],"sourcesContent":["export enum Cursor {\n    POINTER,\n    SINGLE,\n    FILL,\n    GRAB,\n    TEXT,\n    TEXT_ROT,\n    DELETE,\n    ASSIGN,\n    CLEAR,\n    INSPECT\n}\n\nexport enum CellType {\n    OPEN,\n    BOUNDARY,\n    PIT,\n    FIELD,\n    FIELD_ROT,\n    OBJECT,\n    LABEL,\n}\n\nexport enum LabelMode {\n    NUMBER = 1,\n    ADDRESS,\n    TEAM,\n    COLOR\n}\n\nexport enum AutoAssignmentType {\n    ASCENDING,\n    DESCENDING,\n    RANDOM,\n    CLEAR\n}\n\ninterface Point {\n    x: number,\n    y: number\n}\n\nexport interface Rectangle extends Point {\n    w: number,\n    h: number,\n}\n\nexport interface Cell extends Rectangle{\n    type: CellType,\n    label?: string | null,\n    labelRotated?: boolean,\n    ind?: number,\n    team?: number;\n    address?: string,\n    addressGroup?: string | null,\n    color?: string\n}\n\nexport interface PitMapData {\n    objects: Cell[],\n    minX : number,\n    minY: number,\n    width: number,\n    height: number,\n    numbers: boolean,\n    addresses: boolean\n}\n\ninterface Delta {\n    dx: number,\n    dy: number\n}\n\ninterface AddRemoveAction {\n    op: 'ADD' | 'REMOVE',\n    objects: Cell[]\n}\n\ninterface ShiftAction {\n    op: 'SHIFT',\n    delta: Delta\n}\n\ninterface MoveAction {\n    op: 'MOVE',\n    objects: Cell[],\n    delta: Delta\n}\n\ninterface LabelAction {\n    op: 'SET_LABEL',\n    obj: Cell,\n    old?: string | null,\n    label?: string | null\n}\n\ntype Action = AddRemoveAction | ShiftAction | LabelAction | MoveAction\n\n\ninterface PitAssignment { number: number, address: string, team: number }\n\ntype PitClickCallback = (cell : Cell) => void\ntype PitColorCallback = (cell : Cell) => [string, string]\ntype PitAssignCallback = (cells : Cell[], mode : LabelMode) => void\ntype TextSelectCallback = (cell : Cell, callback : (str : string | null) => void) => void\ntype ErrorCallback = (error : { errType: number, number: string | null, max?: number }) => void\n\nconst ZERO_POINT : Point = {x: 0, y: 0} ;\n\nexport default class PitMap {\n    static CELL_PROPS = {\n        [CellType.OPEN]: {\n            width: 1,\n            height: 1,\n            color: 'white',\n            hoverColor: 'rgba(225,225,225,.5)',\n            labelAllowed: false\n        },\n        [CellType.BOUNDARY]: {\n            width: 1,\n            height: 1,\n            color: 'black',\n            hoverColor: 'rgba(0,0,0,.5)',\n            labelAllowed: false\n        },\n        [CellType.PIT]: {\n            width: 2,\n            height: 2,\n            color: 'orange',\n            printColor: 'white',\n            hoverColor: 'rgba(255, 165, 0, .5)',\n            labelAllowed: false\n        },\n        [CellType.FIELD]: {\n            width: 5,\n            height: 3,\n            color: 'white',\n            hoverColor: 'rgba(0, 255, 255, .5)',\n            labelAllowed: true\n        },\n        [CellType.FIELD_ROT]: {\n            width: 3,\n            height: 5,\n            color: 'white',\n            hoverColor: 'rgba(0, 255, 255, .5)',\n            labelAllowed: true\n        },\n        [CellType.OBJECT]: {\n            width: 1,\n            height: 1,\n            color: 'white',\n            hoverColor: 'rgba(255,255,255,.5)',\n            labelAllowed: true\n        },\n        [CellType.LABEL]: {\n            width: 1,\n            height: 1,\n            color: 'white',\n            hoverColor: 'rgba(200,200,200,.5)',\n            labelAllowed: true\n        },\n    }\n    static ERROR_ILLEGAL_NUMBER = 1;\n    static ERROR_DUPLICATE_PIT = 2;\n    static BASE_CELL_SIZE = 20;\n    canvas : HTMLCanvasElement;\n    g : CanvasRenderingContext2D;\n    highlighted? : Cell;\n    cursor = Cursor.POINTER;\n    hover : Point | null = null;\n    dragging = false;\n    dragStart : Point | null = null;\n    dragCurrent : Point | null = null;\n    selectStart : Point | null = null;\n    selectEnd : Point | null = null;\n    grabbedItem : Cell | null = null;\n    grabOffset : Point = ZERO_POINT;\n    grabCurrent : Point = ZERO_POINT;\n    /* Used for cursor select, not fill select */\n    pointerSelected: Cell[] = [];\n    pointerSelectStart : Point | null = null;\n    pointerCurrent: Point | null = null;\n    editing = false;\n    assigning = false;\n    cellType = CellType.OPEN;\n    zoom = 1;\n    undoStack : Action[] = [];\n    redoStack : Action[] = [];\n    objects : Cell[] = [];\n    pitClickCallback? : PitClickCallback;\n    pitColorCallback? : PitColorCallback;\n    pitLabelMode = LabelMode.NUMBER;\n    pitAssignCallback? : PitAssignCallback;\n    assignError? : ErrorCallback;\n    CELL_SIZE = PitMap.BASE_CELL_SIZE;\n    minSize = false;\n    printing: boolean = false;\n    displayTeamNumbers: Record<number, string> = {};\n    activeGroup = 'A';\n    increment = 1;\n    textSelectCallback?: TextSelectCallback;\n\n    constructor({id, textSelectCallback, pitColorCallback, minView} : {\n        id: string,\n        textSelectCallback?: TextSelectCallback,\n        pitColorCallback?: PitColorCallback\n        minView?: boolean\n    }) {\n        const canvasElement = document.getElementById(id);\n        if(!canvasElement) {\n            throw `Element '${id}' not found`\n        }\n        this.canvas = canvasElement as HTMLCanvasElement;\n        const context = this.canvas.getContext('2d');\n        if(!context) {\n            throw `Could not build 2d context`\n        }\n        this.g = context;\n        this.g.save();\n        this.minSize = minView || false;\n        this.pitColorCallback = pitColorCallback;\n        this.textSelectCallback = textSelectCallback;\n        this.canvas.addEventListener('click', this.clickListener)\n        this.canvas.addEventListener('mousedown', this.mouseDownListener);\n        this.canvas.addEventListener('mouseup', this.mouseUpListener);\n        this.canvas.addEventListener('mousemove', this.mouseMoveListener);\n        this.canvas.addEventListener('mouseleave', this.mouseLeaveListener);\n        this.draw();\n    }\n\n    destroy() {\n        this.canvas.removeEventListener('click', this.clickListener);\n        this.canvas.removeEventListener('mousedown', this.mouseDownListener);\n        this.canvas.removeEventListener('mouseup', this.mouseUpListener);\n        this.canvas.removeEventListener('mousemove', this.mouseMoveListener);\n        this.canvas.removeEventListener('mouseleave', this.mouseLeaveListener);\n        this.g.reset();\n    }\n\n    clickListener = (e: MouseEvent) => {\n        let pt = this.getGridCoords({x: e.offsetX, y: e.offsetY});\n        if (this.editing) {\n            if (this.cursor === Cursor.SINGLE) {\n                // TODO if type = OPEN, delete any covered objects\n                let obj = this.getObject(this.cellType, pt, true);\n                const intersecting = this.getIntersectingObjects(obj);\n                if (intersecting.length === 0 && this.cellType === CellType.OPEN) {\n                    return; // dont put empty on top of empty.\n                }\n                this.objects.push(obj);\n                this.pushUndo({op: 'ADD', objects: [obj]});\n                this.draw();\n            } else if (this.cursor === Cursor.DELETE) {\n                const intersecting = this.getIntersectingObjects(Object.assign({w: 0, h: 0}, pt));\n                if (intersecting.length > 0) {\n                    let obj = intersecting[intersecting.length - 1];\n                    obj.ind = this.objects.indexOf(obj);\n                    if (obj.ind > -1) {\n                        this.objects.splice(obj.ind, 1)\n                    }\n                }\n                this.renumberObjects();\n                this.pushUndo({op: 'REMOVE', objects: intersecting});\n                this.draw();\n            } else if (this.cursor === Cursor.TEXT || this.cursor == Cursor.TEXT_ROT) {\n                const intersecting = this.getIntersectingObjects(Object.assign({\n                    w: 0,\n                    h: 0\n                }, pt)).filter(x => PitMap.CELL_PROPS[x.type].labelAllowed);\n                if (intersecting.length && this.textSelectCallback) {\n                    this.textSelectCallback(intersecting[0], (label) => {\n                        this.pushUndo({\n                            op: 'SET_LABEL',\n                            obj: intersecting[0],\n                            old: intersecting[0].label,\n                            label: label\n                        });\n                        intersecting[0].label = label;\n                        intersecting[0].labelRotated = this.cursor == Cursor.TEXT_ROT;\n                        this.draw();\n                    })\n                }\n            } else if (this.cursor === Cursor.GRAB || this.cursor === Cursor.POINTER) {\n                // Grabbed! - ignoring click event\n            }\n        } else if (!this.assigning || this.cursor === Cursor.INSPECT) {\n            const pits = this.getIntersectingObjects(Object.assign({\n                w: 0,\n                h: 0\n            }, pt)).filter(x => x.type === CellType.PIT);\n            if (pits.length === 0) {\n                return;\n            }\n            if(this.pitClickCallback) {\n                this.pitClickCallback(pits[0]);\n            }\n        }\n    }\n\n    mouseDownListener = (e: MouseEvent) => {\n        if(!this.editing && !this.assigning) {\n            return;\n        }\n        const eventPoint = {x: e.offsetX, y: e.offsetY};\n        const intersectionTest = Object.assign(this.getGridCoords(eventPoint), {w: 0, h: 0});\n        if (this.cursor === Cursor.FILL || this.cursor === Cursor.ASSIGN || this.cursor === Cursor.CLEAR) {\n            this.dragging = this.cursor === Cursor.FILL || this.cursor === Cursor.CLEAR || (this.cursor === Cursor.ASSIGN && (this.pitLabelMode === LabelMode.ADDRESS || this.pitLabelMode === LabelMode.COLOR));\n            this.dragStart = eventPoint;\n            this.dragCurrent = this.dragStart;\n            this.selectStart = null;\n            this.selectEnd = null;\n        } else if (this.cursor === Cursor.GRAB) {\n            const grabCandidates = this.getIntersectingObjects(intersectionTest);\n            if (grabCandidates.length > 0) {\n                this.grabbedItem = grabCandidates[grabCandidates.length - 1];\n                // This needs to be how far from the cursor the corner of the grabbed item is - requires pixel coords\n                this.grabOffset = this.grabbedItem ? {x: e.offsetX - (this.grabbedItem.x * this.CELL_SIZE), y: e.offsetY - (this.grabbedItem.y * this.CELL_SIZE)} : ZERO_POINT;\n                this.grabCurrent = eventPoint;\n                this.setCursor(Cursor.GRAB); // update rendered cursor to grabbing\n            }\n        } else if (this.cursor === Cursor.POINTER) {\n            this.pointerSelectStart = eventPoint;\n            if (this.pointerSelected.length > 0 && this.pointerSelected.some(x => intersect(intersectionTest, x))) {\n                // dragging the selected items\n                this.pointerCurrent = eventPoint;\n            } else {\n                // Creating a new selection grid\n                this.pointerSelected = [];\n            }\n        }\n    }\n\n    mouseUpListener = (e: MouseEvent) => {\n        if(!this.editing && !this.assigning) {\n            return;\n        }\n        if (this.dragging) {\n            this.selectStart = this.dragStart;\n            this.selectEnd = this.dragCurrent;\n            this.dragging = false;\n            this.draw();\n        }\n        if (this.grabbedItem) {\n            // drop the grabbed item & update it\n            const gridCoords = this.getGridCoords({x: e.offsetX - this.grabOffset.x, y: e.offsetY - this.grabOffset.y});\n            if (gridCoords.x !== this.grabbedItem.x || gridCoords.y !== this.grabbedItem.y) {\n                this.pushUndo({\n                    op: 'MOVE',\n                    objects: [this.grabbedItem],\n                    delta: {dx: gridCoords.x - this.grabbedItem.x, dy: gridCoords.y - this.grabbedItem.y}\n                });\n                this.grabbedItem.x = gridCoords.x;\n                this.grabbedItem.y = gridCoords.y;\n            }\n            this.grabbedItem = null;\n            this.grabOffset = ZERO_POINT;\n            this.grabCurrent = ZERO_POINT;\n            this.setCursor(Cursor.GRAB); // update rendered cursor to grab\n        }\n        if (this.cursor === Cursor.POINTER) {\n            // set the pointerSelected array\n            const curr = {x: e.offsetX, y: e.offsetY};\n            const rect = this.getRectFromCorners(this.getGridCoords(this.pointerSelectStart ?? curr), this.getGridCoords(curr))\n            forceQ3(rect);\n            if (this.pointerSelected.length === 0) {\n                this.pointerSelected = this.getIntersectingObjects(rect);\n            } else {\n                const gridDeltaPt = this.getGridCoords({x: this.pointerCurrent!.x - this.pointerSelectStart!.x, y: this.pointerCurrent!.y - this.pointerSelectStart!.y})\n                const gridDelta = {dx: gridDeltaPt.x, dy: gridDeltaPt.y};\n                for (let obj of this.pointerSelected) {\n                    obj.x += gridDelta.dx;//newLoc.x;\n                    obj.y += gridDelta.dy;\n                }\n                this.pushUndo({\n                    op: 'MOVE',\n                    objects: [...this.pointerSelected],\n                    delta: gridDelta\n                });\n            }\n            this.pointerCurrent = null;\n            this.pointerSelectStart = null;\n            this.draw();\n        }\n        if (this.assigning && (this.cursor === Cursor.ASSIGN || this.cursor === Cursor.SINGLE || this.cursor == Cursor.CLEAR)) {\n            let selectRect = Object.assign(this.getGridCoords({x: e.offsetX, y: e.offsetY}), {w: 0, h: 0});\n            if ((this.pitLabelMode === LabelMode.ADDRESS || this.pitLabelMode === LabelMode.COLOR || this.cursor == Cursor.CLEAR) && this.selectStart && this.selectEnd) {\n                selectRect = this.getRectFromCorners(this.getGridCoords(this.selectStart), this.getGridCoords(this.selectEnd));\n                forceQ3(selectRect);\n            }\n            const pits = this.getIntersectingObjects(selectRect).filter(x => x.type === CellType.PIT);\n            console.log(pits, this.cursor, this.pitLabelMode)\n            if(pits.length > 0) {\n                if (this.cursor == Cursor.CLEAR) {\n                    this.assign(pits, this.pitLabelMode, null);\n                } else if (this.pitAssignCallback) {\n                    this.pitAssignCallback(pits, this.pitLabelMode);\n                }\n            }\n        }\n    }\n\n    mouseMoveListener = (e: MouseEvent) => {\n        const offsetPoint = {x: e.offsetX, y: e.offsetY};\n        if (this.dragging) {\n            this.dragCurrent = offsetPoint;\n            this.draw();\n        } else if (this.grabbedItem) {\n            this.grabCurrent = offsetPoint;\n            this.draw();\n        } else if (this.cursor === Cursor.POINTER && this.pointerSelectStart) {\n            this.pointerCurrent = offsetPoint;\n            this.draw();\n        } else {\n            this.dragCurrent = null;\n            if (this.cursor === Cursor.SINGLE || this.cursor === Cursor.DELETE) {\n                this.hover = offsetPoint;\n                this.draw();\n            }\n        }\n    }\n\n    mouseLeaveListener = (e: MouseEvent) => {\n        this.hover = null;\n        this.grabbedItem = null;\n        this.pointerCurrent = null;\n        this.pointerSelectStart = null;\n        this.draw();\n    }\n\n    getObject(type : CellType, pt : Point, num : boolean = false) : Cell {\n        const typeGroup = type === CellType.FIELD || type === CellType.FIELD_ROT ? [CellType.FIELD, CellType.FIELD_ROT] : [type];\n        return {\n            type: this.cellType,\n            x: pt.x,\n            y: pt.y,\n            w: PitMap.CELL_PROPS[this.cellType].width,\n            h: PitMap.CELL_PROPS[this.cellType].height,\n            label: num && type === CellType.PIT ? this.objects.filter(x => typeGroup.includes(x.type)).length + 1 + \"\" : null\n        }\n    }\n\n    getSelectRect() {\n        return {\n            x: this.selectStart!.x,\n            y: this.selectStart!.y,\n            w: this.selectEnd!.x - this.selectStart!.x,\n            h: this.selectEnd!.y - this.selectStart!.y\n        }\n    }\n\n    drawCursor() {\n        if (this.cursor === Cursor.SINGLE || this.cursor === Cursor.POINTER) {\n            this.canvas.style['cursor'] = 'default';\n        } else if (this.cursor === Cursor.FILL) {\n            this.canvas.style['cursor'] = 'cell';\n        } else if (this.cursor === Cursor.GRAB) {\n            this.canvas.style['cursor'] = this.grabbedItem ? 'grabbing': 'grab';\n        } else if (this.cursor === Cursor.TEXT || this.cursor === Cursor.TEXT_ROT) {\n            this.canvas.style['cursor'] = 'text';\n        } else if (this.cursor === Cursor.DELETE) {\n            this.canvas.style['cursor'] = 'default';\n        } else if (this.cursor === Cursor.INSPECT) {\n            this.canvas.style['cursor'] = 'help';\n        } else if (this.cursor === Cursor.CLEAR) {\n            this.canvas.style['cursor'] = 'default';\n        } else if (this.cursor === Cursor.ASSIGN) {\n            this.canvas.style['cursor'] = 'default';\n        }\n    }\n\n    draw() {\n        // TODO optimize this to only redraw the area that has changed since last draw\n        this.g.save();\n        this.drawCursor();\n        let h = 0;\n        let w = 0;\n        if (this.minSize) { // render exact size canvas (NOT FOR EDITING!)\n            const bb = this.getBoundingBox();\n            w = this.CELL_SIZE * bb.w;\n            h = this.CELL_SIZE * bb.h;\n        } else {\n            w = this.CELL_SIZE * Math.floor((this.canvas.parentNode as Element).clientWidth / this.CELL_SIZE);\n            h = this.CELL_SIZE * Math.floor(window.innerHeight * .75 / this.CELL_SIZE);\n        }\n        // https://stackoverflow.com/a/65124939\n        this.canvas.height = h * window.devicePixelRatio;\n        this.canvas.style.height = h + 'px';\n        this.canvas.width = w * window.devicePixelRatio;\n        this.canvas.style.width = w + 'px';\n        this.g.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n        this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.g.lineWidth = this.zoom;\n        // draw grid\n        this.g.fillStyle = 'black';\n        this.g.strokeStyle = 'black';\n        if (this.editing) {\n            for (let x = 0; x < 2000 * this.zoom; x += this.CELL_SIZE) {\n                for (let y = 0; y < 2000 * this.zoom; y += this.CELL_SIZE) {\n                    this.g.strokeRect(x, y, this.CELL_SIZE, this.CELL_SIZE);\n                }\n            }\n        }\n\n        for (let obj of this.objects) {\n            const hoverStyle = this.editing &&\n                // 'hover' style if grabbed or if being dragged in a group\n                ((!!this.grabbedItem && obj === this.grabbedItem) || (this.pointerSelected.includes(obj) && !!this.pointerCurrent));\n            const selectedStyle = this.pointerSelected.includes(obj) && !this.pointerCurrent;\n            this.drawObject(obj, hoverStyle, selectedStyle);\n        }\n\n        // draw selections:\n        if (this.editing) {\n            if (this.selectStart && this.selectEnd) {\n                let selectRect = this.getSelectRect();\n                this.snapToGrid(selectRect);\n                this.fillCells(selectRect, 'yellow');\n            }\n            if (this.dragging) {\n                let dragRect = {\n                    x: this.dragStart!.x,\n                    y: this.dragStart!.y,\n                    w: this.dragCurrent!.x - this.dragStart!.x,\n                    h: this.dragCurrent!.y - this.dragStart!.y\n                };\n                this.snapToGrid(dragRect);\n                this.fillCells(dragRect, 'yellow');\n            }\n            if (this.grabbedItem) {\n                let obj = Object.assign({}, this.grabbedItem, this.getGridCoords({x: this.grabCurrent.x - this.grabOffset.x, y: this.grabCurrent.y - this.grabOffset.y}));\n                this.drawObject(obj, false);\n            }\n            if (this.pointerSelected.length > 0 && this.pointerCurrent) {\n                // draw the group in their intermediate drag location\n                for (let obj of this.pointerSelected) {\n                    const temp = Object.assign({}, obj, this.getGridCoords({x: this.CELL_SIZE * obj.x + (this.pointerCurrent!.x - this.pointerSelectStart!.x), y: this.CELL_SIZE * obj.y + (this.pointerCurrent!.y - this.pointerSelectStart!.y)}));\n                    this.drawObject(temp, false, true);\n                }\n            }\n            // draw hover\n            if (this.hover) {\n                if (this.cursor === Cursor.SINGLE) {\n                    let obj = this.getObject(this.cellType, this.getGridCoords(this.hover));\n                    this.drawObject(obj, true);\n                } else if (this.cursor === Cursor.DELETE) {\n                    this.g.strokeStyle = 'red';\n                    for (let obj of this.getIntersectingObjects(Object.assign({\n                        w: 0,\n                        h: 0\n                    }, this.getGridCoords(this.hover)))) {\n                        this.g.strokeRect(obj.x * this.CELL_SIZE, obj.y * this.CELL_SIZE, this.CELL_SIZE * obj.w, this.CELL_SIZE * obj.h);\n                        this.g.strokeRect(obj.x * this.CELL_SIZE + 1, obj.y * this.CELL_SIZE + 1, this.CELL_SIZE * obj.w - 2, this.CELL_SIZE * obj.h - 2);\n                    }\n                }\n            }\n            if (this.pointerCurrent && this.pointerSelected.length === 0) {\n                let pointerSelectRect = {\n                    x: this.pointerSelectStart!.x,\n                    y: this.pointerSelectStart!.y,\n                    w: this.pointerCurrent!.x - this.pointerSelectStart!.x,\n                    h: this.pointerCurrent!.y - this.pointerSelectStart!.y\n                };\n                this.g.strokeStyle = '#0078D7';\n                this.g.fillStyle = 'rgba(170, 204, 238, .5)';\n                this.g.fillRect(pointerSelectRect.x, pointerSelectRect.y, pointerSelectRect.w, pointerSelectRect.h);\n                this.g.strokeRect(pointerSelectRect.x, pointerSelectRect.y, pointerSelectRect.w, pointerSelectRect.h);\n            }\n        } else if (this.assigning) {\n            // draw selection square\n            if (this.dragging) {\n                //\n                let dragRect = {\n                    x: this.dragStart!.x,\n                    y: this.dragStart!.y,\n                    w: this.dragCurrent!.x - this.dragStart!.x,\n                    h: this.dragCurrent!.y - this.dragStart!.y\n                };\n                this.g.strokeStyle = '#0078D7';\n                this.g.fillStyle = 'rgba(170, 204, 238, .5)';\n                this.g.fillRect(dragRect.x, dragRect.y, dragRect.w, dragRect.h);\n                this.g.strokeRect(dragRect.x, dragRect.y, dragRect.w, dragRect.h);\n            }\n\n        }\n\n        this.g.fillStyle = 'auto';\n    }\n\n    drawObject(obj : Cell, hover = false, selectedStyle = false) {\n        //this.g.fillStyle = 'black';\n        if (obj.type !== CellType.LABEL) { // label is just an object with no border\n            this.g.strokeRect(obj.x * this.CELL_SIZE, obj.y * this.CELL_SIZE, this.CELL_SIZE * obj.w, this.CELL_SIZE * obj.h);\n        }\n        const cellProps = PitMap.CELL_PROPS[obj.type];\n        if(obj.type == CellType.PIT && this.pitColorCallback && !this.printing) {\n            this.g.fillStyle = this.pitColorCallback(obj)[0]\n        } else if (obj.type === CellType.PIT && obj.color) {\n            this.g.fillStyle = obj.color;\n        } else {\n            this.g.fillStyle = this.printing ? ('printColor' in cellProps ? cellProps.printColor : cellProps.color) : (hover ? cellProps.hoverColor : cellProps.color);\n        }\n        if (obj === this.highlighted) {\n            this.g.fillStyle = 'cyan';\n        }\n        this.g.fillRect(obj.x * this.CELL_SIZE + this.zoom / 2.0, obj.y * this.CELL_SIZE + this.zoom / 2.0, this.CELL_SIZE * obj.w - this.zoom, this.CELL_SIZE * obj.h - this.zoom);\n        // 22 x 12 in 25x15 area! = 1.5ft margins = 1.5 * pit_width / 10\n        let gap = Math.round(1.5 * this.CELL_SIZE * 2 / 10); //approx scale field to 10x10 pit size\n        let fieldWall = Math.round(12 * this.CELL_SIZE * 2 / 10); //approx scale field to 10x10 pit size\n        let allianceStation = Math.round(3.5 * this.CELL_SIZE * 2 / 10); //approx scale field to 10x10 pit size\n        this.g.fillStyle = 'black';\n        if (obj.type === CellType.FIELD) {\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap, obj.y * this.CELL_SIZE + gap, allianceStation, fieldWall);\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap + allianceStation + gap, obj.y * this.CELL_SIZE + gap, fieldWall, fieldWall);\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap + allianceStation + gap + fieldWall + gap, obj.y * this.CELL_SIZE + gap, allianceStation, fieldWall);\n        } else if (obj.type === CellType.FIELD_ROT) {\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap, obj.y * this.CELL_SIZE + gap, fieldWall, allianceStation);\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap, obj.y * this.CELL_SIZE + gap + allianceStation + gap, fieldWall, fieldWall);\n            this.g.strokeRect(obj.x * this.CELL_SIZE + gap, obj.y * this.CELL_SIZE + gap + allianceStation + gap + fieldWall + gap, fieldWall, allianceStation);\n        }\n        if (obj.type === CellType.PIT || cellProps.labelAllowed) {\n            let text = obj.label;\n            if (obj.type === CellType.PIT) {\n                switch (this.pitLabelMode) {\n                    case LabelMode.NUMBER:\n                        text = obj.label;\n                        break;\n                    case LabelMode.ADDRESS:\n                        text = this.getFullAddress(obj);\n                        break;\n                    case LabelMode.TEAM:\n                        text = (obj.team ? (this.displayTeamNumbers[obj.team] || obj.team) : \"\") + \"\";\n                        break;\n                }\n            }\n            if (text) {\n                let test = text;\n                if (obj.type === CellType.PIT && this.pitLabelMode === LabelMode.TEAM) {\n                    test = \"88888\"; // force all team numbers to 5-digit fit\n                }\n                // TODO maybe also consider split on white-space and double-line it. Maybe there is a library for this?\n                let f = Math.round(.6 * Math.min(obj.h, obj.w) * this.CELL_SIZE);\n                this.g.font = f + 'px sans-serif'\n                while (this.g.measureText(test).width >= (obj.labelRotated ? obj.h : obj.w) * this.CELL_SIZE - 2 && f > 0) {\n                    f -= 2;\n                    this.g.font = f + 'px sans-serif'\n                }\n                this.g.textAlign = 'center';\n                this.g.textBaseline = 'middle';\n\n                if(obj.type == CellType.PIT && this.pitColorCallback && !this.printing) {\n                    this.g.fillStyle = this.pitColorCallback(obj)[1]\n                }\n                let x = Math.round(this.CELL_SIZE * obj.x + this.CELL_SIZE * obj.w / 2);\n                let y = Math.round(this.CELL_SIZE * obj.y + this.CELL_SIZE * obj.h / 2);\n                this.g.save();\n                this.g.translate(x, y);\n                if (obj.labelRotated) {\n                    this.g.rotate(-Math.PI/2);\n                }\n                this.g.fillText(text, 0, 0);\n                this.g.restore();\n            }\n        }\n        this.g.fillStyle = 'black';\n        if (obj.type !== CellType.LABEL) {\n            const oldStrokeStyle = this.g.strokeStyle;\n            if (selectedStyle && !hover) {\n                this.g.strokeStyle = 'cyan';\n                this.g.strokeRect(obj.x * this.CELL_SIZE - 1, obj.y * this.CELL_SIZE - 1, this.CELL_SIZE * obj.w + 2, this.CELL_SIZE * obj.h + 2);\n            }\n            this.g.strokeRect(obj.x * this.CELL_SIZE, obj.y * this.CELL_SIZE, this.CELL_SIZE * obj.w, this.CELL_SIZE * obj.h);\n            this.g.strokeStyle = oldStrokeStyle;\n        }\n    }\n\n    setCursor(cursor : Cursor) {\n        this.cursor = cursor;\n        this.hover = null;\n        this.selectStart = null;\n        if ([Cursor.SINGLE, Cursor.FILL, Cursor.TEXT, Cursor.TEXT_ROT, Cursor.DELETE].includes(cursor)) {\n            this.pointerSelected = [];\n            // If delete is clicked, do we want to popup ask for mass delete of all selected?\n        }\n        this.draw();\n    }\n\n    /**\n     * Returns the passed pixel coordinates in grid coordinates. This value is based on zoom.\n     */\n    getGridCoords(p : Point) {\n        return {x: Math.floor(p.x / this.CELL_SIZE), y: Math.floor(p.y / this.CELL_SIZE)}\n    }\n\n    /** Returns the bounding box of the cells intersecting the passed rect */\n    snapToGrid(r : Rectangle) {\n        forceQ3(r);\n        let nextX = this.CELL_SIZE * Math.ceil((r.x + r.w) / this.CELL_SIZE);\n        let nextY = this.CELL_SIZE * Math.ceil((r.y + r.h) / this.CELL_SIZE);\n        r.x = this.CELL_SIZE * Math.floor(r.x / this.CELL_SIZE);\n        r.y = this.CELL_SIZE * Math.floor(r.y / this.CELL_SIZE);\n        r.w = nextX - r.x;\n        r.h = nextY - r.y;\n    }\n\n    fillCells(rect : Rectangle, style : string) {\n        let oldStyle = this.g.fillStyle;\n        this.g.fillStyle = style;\n        for (let x = rect.x; x < rect.x + rect.w; x += this.CELL_SIZE) {\n            for (let y = rect.y; y < rect.y + rect.h; y += this.CELL_SIZE) {\n                this.g.fillRect(x + 1, y + 1, this.CELL_SIZE - 2, this.CELL_SIZE - 2);\n            }\n        }\n        this.g.fillStyle = oldStyle;\n    }\n\n    clearSelect() {\n        this.selectStart = null;\n        this.selectEnd = null;\n        this.draw();\n    }\n\n    getRectCorners(rect : Rectangle) {\n        return [this.getGridCoords(rect), this.getGridCoords({x: rect.x + rect.w, y: rect.y + rect.h})];\n    }\n\n    getRectFromCorners(TL : Point, BR : Point) {\n        return {\n            x: TL.x,\n            y: TL.y,\n            w: BR.x - TL.x,\n            h: BR.y - TL.y\n        }\n    }\n\n    setCellType(type : CellType) {\n        this.cellType = type;\n        if (this.cursor === Cursor.FILL && this.selectStart && this.selectEnd) {\n            let selectRect = this.getSelectRect();\n            this.snapToGrid(selectRect);\n            let [TL, BR] = this.getRectCorners(selectRect);\n            if (type === CellType.OPEN || type === CellType.BOUNDARY || type === CellType.OBJECT || type === CellType.LABEL) {\n                // TODO block intersecting items\n                const obj = Object.assign({type: type}, this.getRectFromCorners(TL, BR));\n                this.objects.push(obj);\n                this.pushUndo({op: 'ADD', objects: [obj]});\n                this.clearSelect();\n            } else if (type === CellType.PIT) { // fill the selection with 2x2 pits as far as possible\n                let next = this.objects.filter(x => x.type === type).length + 1;\n                const objList = [];\n                for (let y = TL.y; y < BR.y - 1; y += 2) {\n                    for (let x = TL.x; x < BR.x - 1; x += 2) {\n                        const obj = {type: type, x: x, y: y, w: 2, h: 2, label: next + \"\"};\n                        this.objects.push(obj);\n                        objList.push(obj);\n                        next++;\n                    }\n                }\n                this.pushUndo({op: 'ADD', objects: objList});\n                this.clearSelect();\n            } // else no action\n        }\n    }\n\n    setEditing(edit : boolean) {\n        this.editing = edit;\n        this.draw();\n    }\n\n    setAssigning(assign : boolean) {\n        this.assigning = assign;\n        this.draw();\n    }\n\n    setZoom(zoom : number | null) {\n        zoom = zoom ?? 1;\n        this.zoom = zoom;\n        this.CELL_SIZE = 20 * zoom;\n        this.draw();\n    }\n\n    pushUndo(item : Action) {\n        this.undoStack.push(item);\n        this.redoStack = [];\n    }\n\n    undoRedo(fromStack : Action[], toStack : Action[]) {\n        const swap = (op : Action) => {\n            switch (op.op) {\n                case \"ADD\":\n                    op.op = \"REMOVE\";\n                    break;\n                case \"REMOVE\":\n                    op.op = \"ADD\";\n                    break;\n                case \"SHIFT\":\n                case \"MOVE\":\n                    op.delta = {dx: op.delta.dx * -1, dy: op.delta.dy * -1};\n                    break;\n                case 'SET_LABEL':\n                    const temp = op.old;\n                    op.old = op.label;\n                    op.label = temp;\n                    break;\n            }\n            return op;\n        }\n        let op = fromStack.pop();\n        if (op) {\n            switch (op.op) {\n                case 'ADD':\n                case 'REMOVE':\n                    for (let obj of op.objects) {\n                        if (op.op === 'ADD') { // perform a remove\n                            obj.ind = this.objects.indexOf(obj);\n                            if (obj.ind > -1) {\n                                this.objects.splice(obj.ind, 1)\n                            }\n                        } else if (op.op === 'REMOVE') { // perform an add\n                            this.objects.splice(<number>obj.ind, 0, obj);\n                        }\n                    }\n                    if (op.objects.some(x => x.type === CellType.PIT)) {\n                        this.renumberObjects();\n                    }\n                    break;\n                case 'SHIFT':\n                    this.performShift({dx: op.delta.dx * -1, dy: op.delta.dy * -1});\n                    break;\n                case 'SET_LABEL':\n                    op.obj.label = op.old;\n                    break;\n                case 'MOVE':\n                    for (let obj of op.objects) {\n                        obj.x -= op.delta.dx;\n                        obj.y -= op.delta.dy;\n                    }\n                    break;\n            }\n            toStack.push(swap(op));\n            this.draw();\n        }\n    }\n\n    undo() {\n        this.undoRedo(this.undoStack, this.redoStack);\n    }\n\n    redo() {\n        this.undoRedo(this.redoStack, this.undoStack);\n    }\n\n    /**\n     * Returns a list of objects that intersect the given Rectangle\n     */\n    getIntersectingObjects(obj : Rectangle) {\n        return this.objects.filter(x => intersect(obj, x));\n    }\n\n    renumberObjects() {\n        let pitCount = 0;\n        const groupCounts : Record<string, number> = {};\n        for (let obj of this.objects) {\n            if (obj.type === CellType.PIT) {\n                obj.label = (++pitCount) + \"\";\n            }\n        }\n    }\n\n    setDisplayTeamNumbers(data: Record<number, string>) {\n        this.displayTeamNumbers = data;\n    }\n\n    setData(data : Cell[]) {\n        this.objects = data;\n        if (this.minSize) {\n            const bb = this.getBoundingBox();\n            for (let o of this.objects) {\n                o.x -= bb.x;\n                o.y -= bb.y;\n            }\n        }\n        this.draw();\n    }\n\n    getBoundingBox() {\n        let minX = this.objects.length > 0 ? this.objects.reduce((p, c) => Math.min(p, c.x), 99999) : 0;\n        let minY = this.objects.length > 0 ? this.objects.reduce((p, c) => Math.min(p, c.y), 99999) : 0;\n        let maxX = this.objects.length > 0 ? this.objects.reduce((p, c) => Math.max(p, c.x + c.w), -99999) : 0;\n        let maxY = this.objects.length > 0 ? this.objects.reduce((p, c) => Math.max(p, c.y + c.h), -99999) : 0;\n        return {x: minX, y: minY, w: maxX - minX, h: maxY - minY};\n    }\n\n    getData() : PitMapData {\n        const bb = this.getBoundingBox();\n        return JSON.parse(JSON.stringify({\n            objects: this.objects,\n            minX: bb.x,\n            minY: bb.y,\n            width: bb.w,\n            height: bb.h,\n            numbers: true,\n            addresses: true\n        })); // deep copy\n    }\n\n    performShift(delta : Delta) {\n        for (let obj of this.objects) {\n            obj.x += delta.dx;\n            obj.y += delta.dy;\n        }\n        this.draw();\n    }\n\n    shift(dir : 'up' | 'right' | 'down' | 'left') {\n        const delta = {\n            up: {dx: 0, dy: -1},\n            right: {dx: 1, dy: 0},\n            down: {dx: 0, dy: 1},\n            left: {dx: -1, dy: 0},\n        }[dir]\n        this.pushUndo({op: \"SHIFT\", delta: delta});\n        this.performShift(delta);\n    }\n\n    setPitClickCallback(cb : PitClickCallback) {\n        this.pitClickCallback = cb;\n    }\n\n    setPitLabelMode(mode : LabelMode) {\n        this.pitLabelMode = mode;\n        this.draw();\n    }\n\n    setPitAssignCallback(cb : PitAssignCallback) {\n        this.pitAssignCallback = cb;\n    }\n\n    setIncrement(inc: number) {\n        this.increment = inc;\n    }\n\n    getIncrement() {\n        return this.increment;\n    }\n\n    setActiveGroup(prefix: string) {\n        this.activeGroup = prefix;\n    }\n\n    getActiveGroup() {\n        return this.activeGroup;\n    }\n\n    getPitObjects() {\n        return this.objects.filter(x => x.type === CellType.PIT);\n    }\n\n    setAssignError(cb : ErrorCallback) {\n        this.assignError = cb;\n    }\n\n    assign(pits : Cell[], mode : LabelMode, val : string | null) {\n        if (mode === LabelMode.NUMBER) { // swap pit objects.\n            const pit = pits[0]; // only 1 at a time.\n            if (pit.label === val || pit.label === (val + \"\")) { //noop\n                console.log(\"Pit set to current value\", val);\n                return;\n            }\n            const others = this.getPitObjects().filter(x => x.label === val && x !== pit);\n            if (others.length === 0 && this.assignError) {\n                this.assignError({errType: PitMap.ERROR_ILLEGAL_NUMBER, number: val, max: this.getPitObjects().length});\n                return;\n            }\n            if (others.length > 1 && this.assignError) {\n                this.assignError({errType: PitMap.ERROR_DUPLICATE_PIT, number: val});\n                return;\n            }\n            const other = others[0];\n            const otherClone = Object.assign({}, other);\n            // swap the values of the two objects, setting the new labels appropriately\n            Object.assign(other, pit, {label: val});\n            Object.assign(pit, otherClone, {label: pit.label});\n            this.renumberObjects();\n        } else if (mode === LabelMode.ADDRESS) {\n            if (!val && val !== null) {\n                val = null;\n            }\n            pits.forEach(pit => pit.address = val ? val : undefined);\n        } else if (mode === LabelMode.TEAM) {\n            if (pits.length > 1 && this.assignError) { // if this happens our assignment editor code messed up, so reuse the contact support\" duplicate error msg\n                this.assignError({errType: PitMap.ERROR_DUPLICATE_PIT, number: val});\n                return;\n            }\n            pits[0].team = parseInt(val ?? \"\") || undefined;\n        } else if (mode === LabelMode.COLOR) {\n            pits.forEach(pit => pit.color = val ? val : undefined);\n        }\n        this.draw();\n    }\n\n    findTeam(team : string) {\n        const teamNum = parseInt(team);\n        return this.getPitObjects().find(x => x.team === teamNum);\n    }\n\n    setHighlighted(obj : Cell) {\n        this.highlighted = obj;\n        this.draw();\n    }\n\n    findPit(num : string) {\n        let numInt = parseInt(num);\n        return this.getPitObjects().find(x => parseInt(x.label || \"\") === numInt);\n    }\n\n    getFullAddress(pit : Cell) {\n        return pit.address ?? \"\";\n    }\n\n    getPitAssignments(): Record<string, PitAssignment> {\n        const assignments : Record<string, PitAssignment> = {};\n        this.getPitObjects().forEach(pit => {\n            if (pit.team) {\n                assignments[pit.team] = {\n                    number: parseInt(pit.label || \"\"),\n                    address: this.getFullAddress(pit),\n                    team: pit.team\n                };\n            }\n        })\n        return assignments;\n    }\n\n    getCanvas() {\n        return this.canvas;\n    }\n\n    autoAssignPits(type : AutoAssignmentType, teams : number[]) {\n        if (type === AutoAssignmentType.CLEAR) {\n            this.objects.filter(x => x.type === CellType.PIT).forEach((v) => v.team = undefined);\n            this.draw();\n            return;\n        }\n        const a2i = (s? : string | null) => parseInt(s ?? \"0\");\n        const pits = this.objects.filter(x => x.type === CellType.PIT).sort((a, b) => a2i(a.label) - a2i(b.label));\n        let unassignedTeams = teams.filter(t => !pits.some(p => p.team === t)).sort((a, b) => a - b);\n        if (type === AutoAssignmentType.DESCENDING) {\n            unassignedTeams.reverse();\n        } else if (type == AutoAssignmentType.RANDOM) { // stil only fills first n\n            // shuffle - Schwartzian transform approach from https://stackoverflow.com/a/46545530\n            unassignedTeams = unassignedTeams.map(value => ({ value, sort: Math.random() }))\n                .sort((a, b) => a.sort - b.sort).map(({ value }) => value);\n        }\n        let i = 0;\n        for (let cell of pits) {\n            if (!cell.team) {\n                if (i < unassignedTeams.length) {\n                    cell.team = unassignedTeams[i++];\n                } else {\n                    break;\n                }\n            }\n        }\n        this.draw();\n    }\n\n    prepareForPrint() {\n        this.printing = true;\n        this.draw();\n    }\n\n    donePrinting() {\n        this.printing = false;\n        this.draw();\n    }\n}\n\nfunction intersect(r1 : Rectangle, r2 : Rectangle) {\n    let left = r1.x + r1.w < r2.x;\n    let right = r1.x >= r2.x + r2.w;\n    let above = r1.y + r1.h < r2.y;\n    let below = r1.y >= r2.y + r2.h;\n    return !(left || right || above || below);\n}\n\nfunction forceQ3(r : Rectangle) {\n    if (r.w < 0) {\n        r.x += r.w;\n        r.w *= -1;\n    }\n    if (r.h < 0) {\n        r.y += r.h;\n        r.h *= -1;\n    }\n}\n\n\n\n"],"names":["Cursor","Cursor2","CellType","CellType2","LabelMode","LabelMode2","AutoAssignmentType","AutoAssignmentType2","ZERO_POINT","_PitMap","id","textSelectCallback","pitColorCallback","minView","__publicField","e","pt","obj","intersecting","x","label","pits","eventPoint","intersectionTest","grabCandidates","intersect","gridCoords","curr","rect","forceQ3","gridDeltaPt","gridDelta","selectRect","offsetPoint","canvasElement","context","type","num","typeGroup","h","w","bb","y","hoverStyle","selectedStyle","dragRect","temp","pointerSelectRect","hover","cellProps","gap","fieldWall","allianceStation","text","test","f","oldStrokeStyle","cursor","p","r","nextX","nextY","style","oldStyle","TL","BR","next","objList","edit","assign","zoom","item","fromStack","toStack","swap","op","pitCount","data","o","minX","c","minY","maxX","maxY","delta","dir","cb","mode","inc","prefix","val","pit","others","other","otherClone","team","teamNum","numInt","assignments","teams","v","a2i","s","a","b","unassignedTeams","t","value","i","cell","PitMap","r1","r2","left","right","above","below"],"mappings":"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"}